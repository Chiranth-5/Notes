// /*
// Binary search tree:
// 1.At any node all the elements of left subtree is smaller than that node and all the lements on right subtree are larger than that node.
// 2.Inorder traversal is always sorted.
// 3.BST will never have duplicates.
// 4.This is usually used for searching with less number of comparision so the name serch is used.

// 5.Can be generated by knoowing preorder or post order(We can get Inorder by just rearranging them)
// 6.Can be genrated using stack as well(Thats how we normally thing and do)

// 7. Drawbacks: The way its inserted will determine the height of the tree. 
// The first node inserted is fixed as root then the heght varies based on the element sbeing added later.
// So hiegt varies from O(log n) to O(n). SoAVL

// */
// #include <iostream>

// struct Node
// {
//     Node *lchild;
//     int data;
//     Node *rchild;
// } *root;

// Node *searchBSTR(struct Node *p, int key)
// {
//     // Recursive approach
//     if (!p)
//         return nullptr;

//     if (key == p->data)
//         return p;
//     else if (key > p->data)
//     {
//         return searchBSTR(p->rchild, key);
//     }
//     else
//     {
//         return searchBSTR(p->lchild, key);
//     }
// }

// Node *searchBSTI(struct Node *p, int key)
// {
//     // Iterative approach

//     while (!p)
//     {
//         if (key == p->data)
//             return p;
//         else if (key > p->data)
//         {
//             p = p->rchild;
//         }
//         else
//         {
//             p = p->rchild;
//         }
//     }
//     return nullptr;
// }

// void insertBSTI(int key)
// {
//     // Iterative approach
//     if (root == nullptr)
//     {
//         // creating the new Node for key
//         Node *t = nullptr;
//         t = new Node;
//         t->data = key;
//         t->lchild = t->rchild = nullptr;

//         root = t;
//         return;
//     }

//     // tail pointer r
//     Node *r , *p;

//     //localcopy of root;
//     p = root;
//     while (p)
//     {   
//         r=p;
//         if (key == p->data)
//             return ;
//         else if (key > p->data)
//         {
//             p = p->rchild;
//         }
//         else
//         {
//             p = p->lchild;
//         }
//     }

//     // creating the new Node for key
//     Node *t = nullptr;
//     t = new Node;
//     t->data = key;
//     t->lchild = t->rchild = nullptr;

//     if (key > r->data)
//     {
//         r->rchild = t;
//     }
//     else
//     {
//         r->lchild = t;
//     }

//     return;

// }

// Node *insertBSTR(struct Node *p, int key)
// {
//     // Recursive approach
//     if (!p)
//         return nullptr;

//     if (key == p->data)
//         return p;
//     else if (key > p->data)
//     {
//         return searchBSTR(p->rchild, key);
//     }
//     else
//     {
//         return searchBSTR(p->lchild, key);
//     }
// }

// void inOrder(struct Node *q)
// {   
    
//     if (q)
//     {
//         inOrder(q->lchild);
//         std::cout << q->data << std::endl;
//         inOrder(q->rchild);
//     }
// }

// int hieghtT(struct Node * p)
// {
//     int x,y;
//     if ( p != nullptr)
//     {
//         x = hieghtT(p->lchild); 
//         y = hieghtT(p->rchild);
//         if(x>y)
//         {
//             return x+1;
//         }
//         else
//         {
//             return y+1;
//         }
        
//     }
//     return 0; 
// }

// Node* inOrderSuc(struct Node * p)
// {   
//     if( p == nullptr)
//     {
//         return nullptr;
//     }

//     Node *r = nullptr;
//     while( p != nullptr)
//     {
//         r = p;
//         p = p->lchild;
//     }
//     return r;

// }

// Node* inOrderPre(struct Node * p)
// {   
//     if( p == nullptr)
//     {
//         return nullptr;
//     }

//     Node *r = nullptr;
//     while( p != nullptr)
//     {
//         r = p;
//         p = p->rchild;
//     }
//     return r;

// }

// Node* deleteR(struct Node * p , int key)
// {
//     Node *q= nullptr;
//     //Deleteing if its nullpoitr
//     if( p == nullptr)
//     {
//         return nullptr;
//     }

//     if(p->lchild == nullptr && p->rchild == nullptr)
//     {
//         if(p == root)
//         {
//             root = nullptr;
//             return nullptr;
//         }
//         delete p;
//         return nullptr;
//     }

//     if( key == p->data)
//     {
//         //Compare hieght of leftchild tree and right child treee and choose with the highets hieght
//         if( hieghtT(p->lchild) > hieghtT(p->rchild))
//         {
//             q = inOrderPre(p->lchild);
//             p->data = q->data;
//             p->lchild = deleteR(p->lchild,q->data);
//         }
//         else
//         {
//             q = inOrderSuc(p->rchild);
//             p->data = q->data;
//             p->rchild = deleteR(p->rchild,q->data);
//         }

//     }
//     else if( key < p->data)
//     {
//         p->lchild = deleteR(p->lchild,key);
//     }
//     else
//     {
//         p->rchild = deleteR(p->rchild,key);
//     }

//     return p;
// }

// // int main()
// // {
// //     insertBSTI(5);
// //     std::cout << root->data << std::endl;
// //     insertBSTI(4);
// //     std::cout << root->lchild->data << std::endl<<std::endl;

// //     insertBSTI(2);
// //     insertBSTI(1);
// //     insertBSTI(8);
// //     insertBSTI(6);

// //     inOrder(root);

// //     std::cout << std::endl<<std::endl;
// //     Node *p = deleteR(root,6);
// //     std::cout << std::endl<<std::endl;
// //     inOrder(root);
// //     std::cout << std::endl<<std::endl;
// //     inOrder(p);



// //     // Node *temp = searchBSTR(root,4); 
// //     // std::cout << temp->data << std::endl;


// // }